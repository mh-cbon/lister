# lister

[![travis Status](https://travis-ci.org/mh-cbon/lister.svg?branch=master)](https://travis-ci.org/mh-cbon/lister) [![Appveyor Status](https://ci.appveyor.com/api/projects/status/github/mh-cbon/lister?branch=master&svg=true)](https://ci.appveyor.com/projects/mh-cbon/lister) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/lister)](https://goreportcard.com/report/github.com/mh-cbon/lister) [![GoDoc](https://godoc.org/github.com/mh-cbon/lister?status.svg)](http://godoc.org/github.com/mh-cbon/lister) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package lister generates typed slice.


s/Choose your gun!/[Aux armes!](https://www.youtube.com/watch?v=hD-wD_AMRYc&t=7)/

# TOC
- [Install](#install)
  - [Usage](#usage)
    - [$ lister -help](#-lister--help)
  - [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/main.go](#-demomaingo)
  - [> demo/tomates.go](#-demotomatesgo)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install
```sh
mkdir -p $GOPATH/src/github.com/mh-cbon/lister
cd $GOPATH/src/github.com/mh-cbon/lister
git clone https://github.com/mh-cbon/lister.git .
glide install
go install
```

## Usage

#### $ lister -help
```sh
lister 0.0.0

Usage

  lister [-p name] [...types]

  types:  A list of types such as src:dst.
          A type is defined by its package path and its type name,
          [pkgpath/]name
          If the Package path is empty, it is set to the package name being generated.
          Name can be a valid type identifier such as TypeName, *TypeName, []TypeName 
  -p:     The name of the package output.
```

## Cli examples

```sh
# Create a slice of Tomate to Tomates to tomates.go
lister Tomate:Tomates
# Create a slice of strings to stdout
lister -p main - string:StringSlice
# verbose
lister -vv - demo/*Tomate:SliceTomate 1>/dev/null
```
# API example

Following example demonstates a program using it to generate a slice of `Tomate`

#### > demo/main.go
```go
// Package demo demonstrates usage of Lister.
package main

import "fmt"

//go:generate lister Tomate:Tomates *Poireau:Poireaux

func main() {
	x := NewTomates()
	x.Push(Tomate{Name: "Red"})
	fmt.Println(
		x.Filter(FilterTomates.ByName("Red")).First(),
	)
}

// Tomate is a struct ot describe a Tomate.
type Tomate struct {
	Name   string
	Width  uint64
	Height uint64
}

// GetID of a Tomate
func (t Tomate) GetID() string {
	return t.Name
}

// Poireau is a struct ot describe a Poireau.
type Poireau struct {
	Name   string
	Width  uint64
	Height uint64
}

// GetID of a Poireau
func (t *Poireau) GetID() string {
	return t.Name
}
```

Following is the generated code for a slice of `Tomate`.

#### > demo/tomates.go
```go
package main

// file generated by
// github.com/mh-cbon/lister
// do not edit

// Tomates implements a typed slice of Tomate
type Tomates struct{ items []Tomate }

// NewTomates creates a new typed slice of Tomate
func NewTomates() *Tomates {
	return &Tomates{items: []Tomate{}}
}

// Push appends every Tomate
func (t *Tomates) Push(x ...Tomate) *Tomates {
	t.items = append(t.items, x...)
	return t
}

// Unshift prepends every Tomate
func (t *Tomates) Unshift(x ...Tomate) *Tomates {
	t.items = append(x, t.items...)
	return t
}

// Pop removes then returns the last Tomate.
func (t *Tomates) Pop() Tomate {
	var ret Tomate
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
		t.items = append(t.items[:0], t.items[len(t.items)-1:]...)
	}
	return ret
}

// Shift removes then returns the first Tomate.
func (t *Tomates) Shift() Tomate {
	var ret Tomate
	if len(t.items) > 0 {
		ret = t.items[0]
		t.items = append(t.items[:0], t.items[1:]...)
	}
	return ret
}

// Index of given Tomate. It must implements Ider interface.
func (t *Tomates) Index(s Tomate) int {
	ret := -1
	for i, item := range t.items {
		if s.GetID() == item.GetID() {
			ret = i
			break
		}
	}
	return ret
}

// Contains returns true if s in is t.
func (t *Tomates) Contains(s Tomate) bool {
	return t.Index(s) > -1
}

// RemoveAt removes a Tomate at index i.
func (t *Tomates) RemoveAt(i int) bool {
	if i >= 0 && i < len(t.items) {
		t.items = append(t.items[:i], t.items[i+1:]...)
		return true
	}
	return false
}

// Remove removes given Tomate
func (t *Tomates) Remove(s Tomate) bool {
	if i := t.Index(s); i > -1 {
		t.RemoveAt(i)
		return true
	}
	return false
}

// InsertAt adds given Tomate at index i
func (t *Tomates) InsertAt(i int, s Tomate) *Tomates {
	if i < 0 || i >= len(t.items) {
		return t
	}
	res := []Tomate{}
	res = append(res, t.items[:0]...)
	res = append(res, s)
	res = append(res, t.items[i:]...)
	t.items = res
	return t
}

// Splice removes and returns a slice of Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *Tomates) Splice(start int, length int, s ...Tomate) []Tomate {
	var ret []Tomate
	for i := 0; i < len(t.items); i++ {
		if i >= start && i < start+length {
			ret = append(ret, t.items[i])
		}
	}
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		t.items = append(
			t.items[:start],
			append(s,
				t.items[start+length:]...,
			)...,
		)
	}
	return ret
}

// Slice returns a copied slice of Tomate, starting at start, ending at start+length.
func (t *Tomates) Slice(start int, length int) []Tomate {
	var ret []Tomate
	if start >= 0 && start+length <= len(t.items) && start+length >= 0 {
		ret = t.items[start : start+length]
	}
	return ret
}

// Reverse the slice.
func (t *Tomates) Reverse() *Tomates {
	for i, j := 0, len(t.items)-1; i < j; i, j = i+1, j-1 {
		t.items[i], t.items[j] = t.items[j], t.items[i]
	}
	return t
}

// Len of the slice.
func (t *Tomates) Len() int {
	return len(t.items)
}

// Set the slice.
func (t *Tomates) Set(x []Tomate) *Tomates {
	t.items = append(t.items[:0], x...)
	return t
}

// Get the slice.
func (t *Tomates) Get() []Tomate {
	return t.items
}

// At return the item at index i.
func (t *Tomates) At(i int) Tomate {
	return t.items[i]
}

// Filter return a new Tomates with all items satisfying f.
func (t *Tomates) Filter(filters ...func(Tomate) bool) *Tomates {
	ret := NewTomates()
	for _, i := range t.items {
		ok := true
		for _, f := range filters {
			ok = ok && f(i)
			if !ok {
				break
			}
		}
		if ok {
			ret.Push(i)
		}
	}
	return ret
}

// Map return a new Tomates of each items modified by f.
func (t *Tomates) Map(mappers ...func(Tomate) Tomate) *Tomates {
	ret := NewTomates()
	for _, i := range t.items {
		val := i
		for _, m := range mappers {
			val = m(val)
		}
		ret.Push(val)
	}
	return ret
}

// First returns the first value or default.
func (t *Tomates) First() Tomate {
	var ret Tomate
	if len(t.items) > 0 {
		ret = t.items[0]
	}
	return ret
}

// Last returns the last value or default.
func (t *Tomates) Last() Tomate {
	var ret Tomate
	if len(t.items) > 0 {
		ret = t.items[len(t.items)-1]
	}
	return ret
}

// Empty returns true if the slice is empty.
func (t *Tomates) Empty() bool {
	return len(t.items) == 0
}

// FilterTomates provides filters for a struct.
var FilterTomates = struct {
	ByName   func(string) func(Tomate) bool
	ByWidth  func(uint64) func(Tomate) bool
	ByHeight func(uint64) func(Tomate) bool
}{
	ByName:   func(v string) func(Tomate) bool { return func(o Tomate) bool { return o.Name == v } },
	ByWidth:  func(v uint64) func(Tomate) bool { return func(o Tomate) bool { return o.Width == v } },
	ByHeight: func(v uint64) func(Tomate) bool { return func(o Tomate) bool { return o.Height == v } },
}
```

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
