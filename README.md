# lister

[![travis Status](https://travis-ci.org//mh-cbon/lister.svg?branch=master)](https://travis-ci.org//mh-cbon/lister) [![Appveyor Status](https://ci.appveyor.com/api/projects/status//github/mh-cbon/lister?branch=master&svg=true)](https://ci.appveyor.com/projects//mh-cbon/lister) [![Go Report Card](https://goreportcard.com/badge/github.com/mh-cbon/lister)](https://goreportcard.com/report/github.com/mh-cbon/lister) [![GoDoc](https://godoc.org/github.com/mh-cbon/lister?status.svg)](http://godoc.org/github.com/mh-cbon/lister) [![MIT License](http://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

Package lister is a generator to generate typed slice.


# TOC
- [Install](#install)
  - [Usage](#usage)
    - [$ lister -help](#-lister--help)
  - [Cli examples](#cli-examples)
- [API example](#api-example)
  - [> demo/lib.go](#-demolibgo)
  - [> demo/vegetables_gen.go](#-demovegetables_gengo)
- [Recipes](#recipes)
  - [Release the project](#release-the-project)
- [History](#history)

# Install
```sh
go get github.com/mh-cbon/lister
```

## Usage

#### $ lister -help
```sh
lister 0.0.0

Usage

	lister [-p name] [out] [...types]

	out: 	Output destination of the results, use '-' for stdout.
	types:	A list of types such as src:dst.
	-p:			The name of the package output.
```

## Cli examples

```sh
# Create a typed slice version of Tomate to Tomates
lister tomates_gen.go Tomate:Tomates
```
# API example

Following example demonstates a program using it to generate a lister version of a type.

#### > demo/lib.go
```go
// Package demo demonstrates usage of Lister.
package demo

// Tomate is a struct ot describe a Tomate.
type Tomate struct {
	Name   string
	Width  uint64
	Height uint64
}

// GetID of a Tomate
func (t Tomate) GetID() string {
	return t.Name
}

// Poireau is a struct ot describe a Poireau.
type Poireau struct {
	Name   string
	Width  uint64
	Height uint64
}

// GetID of a Poireau
func (t *Poireau) GetID() string {
	return t.Name
}

//go:generate lister vegetables_gen.go Tomate:Tomates *Poireau:Poireaux
```

Following code is the generated implementation of `Tomates` type.

#### > demo/vegetables_gen.go
```go
package demo

// file generated by
// github.com.mh-cbon/lister
// do not edit

// Tomates implements a typed slice of Tomate
type Tomates []Tomate

// NewTomates creates a new typed slice of Tomate
func NewTomates() *Tomates {
	return &Tomates{}
}

// Push appends every Tomate
func (t *Tomates) Push(x ...Tomate) *Tomates {
	items := *t
	items = append(items, x...)
	return t.Set(items)
}

// Unshift prepends every Tomate
func (t *Tomates) Unshift(x ...Tomate) *Tomates {
	items := *t
	items = append(x, items...)
	return t.Set(items)
}

// Pop removes then reutrns the last Tomate.
func (t *Tomates) Pop() Tomate {
	var ret Tomate
	items := *t
	if len(items) > 0 {
		ret = items[len(items)-1]
		items = append(items[:0], items[len(items)-1:]...)
		t.Set(items)
	}
	return ret
}

// Shift removes then reutrns the first Tomate.
func (t *Tomates) Shift() Tomate {
	var ret Tomate
	items := *t
	if len(items) > 0 {
		ret = items[0]
		items = append(items[:0], items[1:]...)
	}
	t.Set(items)
	return ret
}

// Index of given Tomate. It must implements Ider interface.
func (t *Tomates) Index(s Tomate) int {
	ret := -1
	items := *t
	for i, item := range items {
		if s.GetID() == item.GetID() {
			ret = i
			break
		}
	}
	return ret
}

// RemoveAt removes a Tomate at index i.
func (t *Tomates) RemoveAt(i int) bool {
	items := *t
	if i < len(items) {
		items = append(items[:i], items[i+1:]...)
		t.Set(items)
		return true
	}
	return false
}

// Remove removes given Tomate
func (t *Tomates) Remove(s Tomate) bool {
	if i := t.Index(s); i > -1 {
		t.RemoveAt(i)
		return true
	}
	return false
}

// InsertAt adds given Tomate at index i
func (t *Tomates) InsertAt(i int, s Tomate) *Tomates {
	items := *t
	items = append(
		items[:i],
		append(
			append(items[:0], s),
			items[i+1:]...,
		)...,
	)
	return t.Set(items)
}

// Splice removes and returns a slice of Tomate, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *Tomates) Splice(start int, length int, s ...Tomate) []Tomate {
	items := *t
	ret := items[start : start+length]
	items = append(items[:start], append(s, items[start+length:]...)...)
	t.Set(items)
	return ret
}

// Slice returns a copied slice of Tomate, starting at start, ending at start+length.
func (t *Tomates) Slice(start int, length int) []Tomate {
	items := *t
	return items[start : start+length]
}

// Reverse the slice.
func (t *Tomates) Reverse() *Tomates {
	items := *t
	for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {
		items[i], items[j] = items[j], items[i]
	}
	return t.Set(items)
}

// Len of the slice.
func (t *Tomates) Len() int {
	return len(*t)
}

// Set the slice.
func (t *Tomates) Set(x []Tomate) *Tomates {
	items := *t
	items = append(items[:0], x...)
	t = &items
	return t
}

// Poireaux implements a typed slice of *Poireau
type Poireaux []*Poireau

// NewPoireaux creates a new typed slice of *Poireau
func NewPoireaux() *Poireaux {
	return &Poireaux{}
}

// Push appends every *Poireau
func (t *Poireaux) Push(x ...*Poireau) *Poireaux {
	items := *t
	items = append(items, x...)
	return t.Set(items)
}

// Unshift prepends every *Poireau
func (t *Poireaux) Unshift(x ...*Poireau) *Poireaux {
	items := *t
	items = append(x, items...)
	return t.Set(items)
}

// Pop removes then reutrns the last *Poireau.
func (t *Poireaux) Pop() *Poireau {
	var ret *Poireau
	items := *t
	if len(items) > 0 {
		ret = items[len(items)-1]
		items = append(items[:0], items[len(items)-1:]...)
		t.Set(items)
	}
	return ret
}

// Shift removes then reutrns the first *Poireau.
func (t *Poireaux) Shift() *Poireau {
	var ret *Poireau
	items := *t
	if len(items) > 0 {
		ret = items[0]
		items = append(items[:0], items[1:]...)
	}
	t.Set(items)
	return ret
}

// Index of given *Poireau. It must implements Ider interface.
func (t *Poireaux) Index(s *Poireau) int {
	ret := -1
	items := *t
	for i, item := range items {
		if s.GetID() == item.GetID() {
			ret = i
			break
		}
	}
	return ret
}

// RemoveAt removes a *Poireau at index i.
func (t *Poireaux) RemoveAt(i int) bool {
	items := *t
	if i < len(items) {
		items = append(items[:i], items[i+1:]...)
		t.Set(items)
		return true
	}
	return false
}

// Remove removes given *Poireau
func (t *Poireaux) Remove(s *Poireau) bool {
	if i := t.Index(s); i > -1 {
		t.RemoveAt(i)
		return true
	}
	return false
}

// InsertAt adds given *Poireau at index i
func (t *Poireaux) InsertAt(i int, s *Poireau) *Poireaux {
	items := *t
	items = append(
		items[:i],
		append(
			append(items[:0], s),
			items[i+1:]...,
		)...,
	)
	return t.Set(items)
}

// Splice removes and returns a slice of *Poireau, starting at start, ending at start+length.
// If any s is provided, they are inserted in place of the removed slice.
func (t *Poireaux) Splice(start int, length int, s ...*Poireau) []*Poireau {
	items := *t
	ret := items[start : start+length]
	items = append(items[:start], append(s, items[start+length:]...)...)
	t.Set(items)
	return ret
}

// Slice returns a copied slice of *Poireau, starting at start, ending at start+length.
func (t *Poireaux) Slice(start int, length int) []*Poireau {
	items := *t
	return items[start : start+length]
}

// Reverse the slice.
func (t *Poireaux) Reverse() *Poireaux {
	items := *t
	for i, j := 0, len(items)-1; i < j; i, j = i+1, j-1 {
		items[i], items[j] = items[j], items[i]
	}
	return t.Set(items)
}

// Len of the slice.
func (t *Poireaux) Len() int {
	return len(*t)
}

// Set the slice.
func (t *Poireaux) Set(x []*Poireau) *Poireaux {
	items := *t
	items = append(items[:0], x...)
	t = &items
	return t
}
```

# Recipes

#### Release the project

```sh
gump patch -d # check
gump patch # bump
```

# History

[CHANGELOG](CHANGELOG.md)
