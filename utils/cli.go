package utils

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

//go:generate lister PkgImport:PkgImports

// GetPkgToLoad return the package to load
func GetPkgToLoad() string {
	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	pkgToLoad, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	if len(pkgToLoad) < len(gopath) || pkgToLoad[:len(gopath)] != gopath {
		panic(fmt.Errorf("unexpected gopath %q", gopath))
	}
	return pkgToLoad[len(gopath)+1:]
}

// FilesOut ...
type FilesOut struct {
	Files         []*FileOut
	GeneratorName string
}

// NewFilesOut ...
func NewFilesOut(name string) *FilesOut {
	return &FilesOut{GeneratorName: name}
}

// Get the file handler matching path s
func (f *FilesOut) Get(s string) *FileOut {
	for _, p := range f.Files {
		if p.Path == strings.ToLower(s) {
			return p
		}
	}
	r := &FileOut{GeneratorName: f.GeneratorName, Path: s}
	f.Files = append(f.Files, r)
	return r
}
func (f *FilesOut) Write(to string) {
	for _, file := range f.Files {
		if to == "-" {
			file.Path = to
		}
		if err := file.Write(); err != nil {
			log.Println(err)
		}
	}
}

// FileOut ...
type FileOut struct {
	GeneratorName string
	PkgName       string
	Path          string
	Body          bytes.Buffer
	Imports       PkgImports
}

// PkgImport represents an import
type PkgImport struct {
	Path string
	ID   string
}

// GetID of a PkgImport
func (t PkgImport) GetID() string {
	return t.Path
}

func (t PkgImport) String() string {
	if t.ID == "" {
		return fmt.Sprintf("%q", t.Path)
	}
	return fmt.Sprintf("%v %q", t.ID, t.Path)
}

// AddImport add new imports
func (f *FileOut) AddImport(path, id string) {
	path = strings.TrimSpace(path)
	id = strings.TrimSpace(id)
	e := PkgImport{Path: path, ID: id}
	if len(path+id) > 0 && f.Imports.Contains(e) == false {
		f.Imports.Push(e)
	}
}

func (f *FileOut) Write() error {
	o := f.Path
	dest := os.Stdout
	if o != "-" {
		os.MkdirAll(filepath.Dir(o), os.ModePerm)
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			exec.Command("go", "fmt", o).Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", f.PkgName)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintln(dest, `// `+f.GeneratorName)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, ``)

	if !f.Imports.Empty() {
		s := ""
		f.Imports.Map(func(p PkgImport) PkgImport {
			s += fmt.Sprintf("%v\n", p)
			return p
		})
		fmt.Fprintln(dest, `import (`)
		fmt.Fprintln(dest, s)
		fmt.Fprintln(dest, `)`)
	}

	_, err := io.Copy(dest, &f.Body)
	return err
}

// TransformArgs parse cli args.
type TransformArgs struct {
	PkgBase string
	Args    []TransformArg
}

// NewTransformsArgs ...
func NewTransformsArgs(outPkg string) TransformArgs {
	if outPkg == "" {
		outPkg = os.Getenv("GOPACKAGE")
	}
	if outPkg == "main" {
		outPkg = GetPkgToLoad()
	}
	return TransformArgs{PkgBase: outPkg}
}

// TransformArg is a parsed cli arg.
type TransformArg struct {
	FromPkgPath  string
	FromTypeName string
	ToPkgPath    string
	ToTypeName   string
	ToPath       string
}

func (t TransformArg) String() string {
	ret := ""
	ret += fmt.Sprintln("todo from pkg path:", t.FromPkgPath)
	ret += fmt.Sprintln("todo from type:", t.FromTypeName)
	ret += fmt.Sprintln("todo to pkg path:", t.ToPkgPath)
	ret += fmt.Sprintln("todo to type:", t.ToTypeName)
	ret += fmt.Sprintln("todo save path:", t.ToPath)
	return ret
}

// Parse cli arguments.
func (t TransformArgs) Parse(args []string) (TransformArgs, error) {
	for _, arg := range args {
		y := strings.Split(arg, ":")
		if len(y) != 2 {
			return t, fmt.Errorf("wrong name %q", arg)
		}

		c := TransformArg{}
		c.FromTypeName = filepath.Base(y[0])
		c.FromPkgPath = t.PkgBase
		c.ToPkgPath = t.PkgBase
		c.ToTypeName = filepath.Base(y[1])
		c.ToPath = "-"

		if strings.Index(y[0], "/") > -1 {
			// test if the dir exists locally to the package being generated,
			// if so, update the import path to its absolute path,
			// if not, assume it is already an absolute package path.
			d := filepath.Dir(y[0])
			if _, err := os.Stat(d); !os.IsNotExist(err) {
				c.FromPkgPath = filepath.Join(GetPkgToLoad(), d)
			}
		}

		if strings.Index(y[1], "/") > -1 {
			// if the package path contains a /,
			// build a new out package made of t.base+p,
			// otherwise, it is the package being generated
			d := filepath.Dir(y[1])
			c.ToPkgPath = d
			c.ToPath = filepath.Join(c.ToPkgPath, c.ToTypeName+".go")
		} else {
			c.ToPath = filepath.Join(c.ToTypeName + ".go")
		}
		c.ToPath = strings.ToLower(c.ToPath)
		t.Args = append(t.Args, c)
	}
	return t, nil
}
